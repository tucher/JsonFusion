<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JsonFusion Constexpr Test Suite</title>
<link rel="stylesheet" href="css/docs.css">
<style>
  /* Variables and reset inherited from css/docs.css */
  body {
    font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
    padding: 0;
  }
  .container {
    max-width: 600px;
    margin: 0 auto;
    padding: 24px;
  }
  h1 { font-size: 1.4em; margin-bottom: 4px; }
  .subtitle { color: var(--text-dim); font-size: 0.85em; margin-bottom: 20px; }
  #status {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 16px;
    margin-bottom: 16px;
    white-space: pre-wrap;
    font-size: 0.85em;
    line-height: 1.6;
    max-height: 200px;
    overflow-y: auto;
  }
  #progress-bar-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    height: 8px;
    margin-bottom: 16px;
    overflow: hidden;
  }
  #progress-bar {
    height: 100%;
    background: var(--accent);
    width: 0%;
    transition: width 0.15s;
  }
  #summary {
    display: flex;
    gap: 24px;
    margin-bottom: 16px;
    font-size: 0.95em;
  }
  #summary .count { font-weight: bold; font-size: 1.1em; }
  #summary .pass-count { color: var(--pass); }
  #summary .fail-count { color: var(--fail); }
  #summary .skip-count { color: var(--skip); }
  #summary .total-count { color: var(--text-dim); }
  .category-header {
    background: var(--surface2);
    padding: 6px 12px;
    font-size: 0.8em;
    color: var(--accent);
    border-radius: 4px 4px 0 0;
    margin-top: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .test-row {
    display: flex;
    align-items: center;
    padding: 5px 12px;
    border-bottom: 1px solid var(--border);
    font-size: 0.82em;
    background: var(--surface);
  }
  .test-row:last-child { border-bottom: none; border-radius: 0 0 4px 4px; }
  .test-name { flex: 1; }
  .test-badge {
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 0.8em;
    font-weight: bold;
  }
  .test-badge.pass { background: var(--pass); color: #000; }
  .test-badge.fail { background: var(--fail); color: #fff; cursor: pointer; }
  .test-badge.skip { background: var(--skip); color: #000; }
  .test-badge.running { background: var(--accent); color: #000; }
  .test-diag {
    display: none;
    background: #0a0a1a;
    padding: 8px 12px;
    font-size: 0.75em;
    color: #ff8a80;
    white-space: pre-wrap;
    word-break: break-all;
    border-bottom: 1px solid var(--border);
    max-height: 300px;
    overflow-y: auto;
  }
  .test-diag.open { display: block; }
</style>
</head>
<body>

<header class="site-header">
  <a class="logo" href="index.html">JsonFusion</a>
  <nav>
    <a href="index.html">Docs</a>
    <a href="constexpr-tests.html">Test Suite</a>
    <a href="https://github.com/tucher/JsonFusion">GitHub</a>
  </nav>
</header>

<div class="container">
<h1>Constexpr Test Suite</h1>
<div class="subtitle">
  Running C++ constexpr tests entirely in the browser via Clang compiled to WebAssembly.
</div>

<div id="progress-bar-container"><div id="progress-bar"></div></div>
<div id="status">Initializing...</div>

<div id="summary" style="display:none">
  <div>Passed: <span class="count pass-count" id="pass-count">0</span></div>
  <div>Failed: <span class="count fail-count" id="fail-count">0</span></div>
  <div>Skipped: <span class="count skip-count" id="skip-count">0</span></div>
  <div>Total: <span class="count total-count" id="total-count">0</span></div>
</div>

<div id="results"></div>
</div>

<script type="module">
import { CompilerEngine } from "./js/compiler-engine.mjs";

// ── Configuration ──────────────────────────────────────────────────
const GITHUB_OWNER  = "tucher";
const GITHUB_REPO   = "JsonFusion";
const GITHUB_BRANCH = "master";

const params    = new URLSearchParams(location.search);
const branch    = params.get("branch") || GITHUB_BRANCH;
const localWasm = params.get("local_wasm"); // e.g. http://localhost:8080/

const WASM_BASE = localWasm || `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/wasm-v1/wasm-v1/`;
const RAW_BASE  = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${branch}`;
const API_TREES = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/trees/${branch}?recursive=1`;

const SKIP_PATTERNS = ["annotations/test_cpp26"];

// ── DOM refs ───────────────────────────────────────────────────────
const statusEl   = document.getElementById("status");
const progressEl = document.getElementById("progress-bar");
const summaryEl  = document.getElementById("summary");
const resultsEl  = document.getElementById("results");
const passEl     = document.getElementById("pass-count");
const failEl     = document.getElementById("fail-count");
const skipEl     = document.getElementById("skip-count");
const totalEl    = document.getElementById("total-count");

function log(msg) {
  statusEl.textContent += msg + "\n";
  statusEl.scrollTop = statusEl.scrollHeight;
}

function setProgress(pct) {
  progressEl.style.width = Math.min(100, pct) + "%";
}

// ── Fetch helper ───────────────────────────────────────────────────
async function fetchAllPooled(urls, concurrency = 30) {
  const results = new Array(urls.length);
  let idx = 0;
  async function worker() {
    while (idx < urls.length) {
      const i = idx++;
      const resp = await fetch(urls[i]);
      if (!resp.ok) throw new Error(`Fetch failed: ${urls[i]} (${resp.status})`);
      results[i] = await resp.text();
    }
  }
  const workers = [];
  for (let w = 0; w < Math.min(concurrency, urls.length); w++) workers.push(worker());
  await Promise.all(workers);
  return results;
}

// ── Phase 1: Initialize compiler engine ────────────────────────────
log("Initializing compiler engine...");

const engine = new CompilerEngine({
  wasmBaseUrl: WASM_BASE,
  githubOwner: GITHUB_OWNER,
  githubRepo: GITHUB_REPO,
  githubBranch: branch,
});

try {
  await engine.init();
  log(`  ${engine.workerCount} workers ready`);
} catch (err) {
  log(`Error initializing engine: ${err.message}`);
  throw err;
}

setProgress(25);

// ── Phase 2: Load standard headers into all workers ────────────────
log("Loading standard headers...");

try {
  const nHeaders = await engine.loadStandardHeaders();
  log(`  ${nHeaders} headers loaded into ${engine.workerCount} workers`);
} catch (err) {
  log(`Error loading headers: ${err.message}`);
  throw err;
}

setProgress(40);

// ── Phase 3: Discover test files via GitHub Trees API ──────────────
log("Discovering test files...");

let testPaths, helpersPath;

try {
  const resp = await fetch(API_TREES);
  if (!resp.ok) throw new Error(`Trees API returned ${resp.status}`);
  const treeData = await resp.json();

  if (treeData.truncated) {
    log("  Warning: tree response was truncated. Some files may be missing.");
  }

  const allFiles = treeData.tree
    .filter(e => e.type === "blob")
    .map(e => e.path);

  testPaths = allFiles.filter(p =>
    p.startsWith("tests/constexpr/") &&
    /\/test_[^/]+\.cpp$/.test(p)
  );

  helpersPath = allFiles.find(p => p === "tests/constexpr/test_helpers.hpp");

  testPaths.sort();
  log(`  Found ${testPaths.length} test files`);
} catch (err) {
  log(`Error discovering files: ${err.message}`);
  throw err;
}

// ── Phase 4: Fetch test helpers & test files ───────────────────────
log("Fetching test files...");

let testContents;

try {
  // Load test_helpers.hpp into all workers
  if (helpersPath) {
    const helpersResp = await fetch(`${RAW_BASE}/${helpersPath}`);
    if (!helpersResp.ok) throw new Error(`Failed to fetch helpers: ${helpersResp.status}`);
    await engine.writeSharedFiles([{
      path: "/" + helpersPath,
      content: await helpersResp.text(),
    }]);
    log("  test_helpers.hpp loaded into all workers");
  }

  // Fetch all test .cpp files in parallel
  const testUrls = testPaths.map(p => `${RAW_BASE}/${p}`);
  testContents = await fetchAllPooled(testUrls);
  log(`  ${testPaths.length} test files fetched`);
} catch (err) {
  log(`Error fetching test files: ${err.message}`);
  throw err;
}

setProgress(60);

// ── Phase 5: Build UI & run tests in parallel ──────────────────────
log(`Running tests across ${engine.workerCount} workers...\n`);
summaryEl.style.display = "flex";

// Build test list grouped by category
const categories = {};
const testList = [];

for (let i = 0; i < testPaths.length; i++) {
  const tp = testPaths[i];
  const parts = tp.split("/");
  const category = parts.length > 3 ? parts[2] : "(root)";
  const filename = parts[parts.length - 1];
  const name = filename.replace(/\.cpp$/, "").replace(/^test_/, "");
  const id = `${category}--${name}`;
  const rel = tp.replace("tests/constexpr/", "");

  if (!categories[category]) categories[category] = [];
  categories[category].push({ name, id });
  testList.push({ path: tp, name, category, id, rel, contentIdx: i });
}

// Build UI skeleton
for (const [cat, tests] of Object.entries(categories)) {
  const header = document.createElement("div");
  header.className = "category-header";
  header.textContent = cat;
  resultsEl.appendChild(header);

  for (const t of tests) {
    const row = document.createElement("div");
    row.className = "test-row";
    row.innerHTML = `<span class="test-name">${t.name}</span><span class="test-badge" id="badge-${t.id}">...</span>`;
    resultsEl.appendChild(row);

    const diag = document.createElement("div");
    diag.className = "test-diag";
    diag.id = `diag-${t.id}`;
    resultsEl.appendChild(diag);
  }
}

// Counters
let pass = 0, fail = 0, skip = 0, completed = 0;
const total = testList.length;
totalEl.textContent = total;

// Fire all tests — the engine's worker pool handles scheduling
const promises = testList.map(({ path: tp, id, rel, contentIdx }) => {
  const badge = document.getElementById(`badge-${id}`);
  const diagEl = document.getElementById(`diag-${id}`);

  // Skip C++26 tests
  if (SKIP_PATTERNS.some(pat => rel.includes(pat))) {
    badge.textContent = "SKIP";
    badge.className = "test-badge skip";
    skip++;
    completed++;
    skipEl.textContent = skip;
    return Promise.resolve();
  }

  badge.textContent = "...";
  badge.className = "test-badge running";

  return engine.compile({
    code: testContents[contentIdx],
    path: "/" + tp,
    mode: "check-only",
    std: "c++23",
    includeDirs: ["/tests/constexpr"],
  }).then(result => {
    completed++;

    if (result.ok) {
      badge.textContent = "PASS";
      badge.className = "test-badge pass";
      pass++;
    } else {
      badge.textContent = "FAIL";
      badge.className = "test-badge fail";
      fail++;

      const diagText = result.diagnostics || result.error || "Unknown error";
      diagEl.textContent = diagText;
      badge.addEventListener("click", () => diagEl.classList.toggle("open"));
    }

    passEl.textContent = pass;
    failEl.textContent = fail;
    skipEl.textContent = skip;
    setProgress(60 + (40 * completed / total));
  });
});

await Promise.all(promises);

// Final status
setProgress(100);
const finalMsg = fail === 0
  ? `All ${pass} tests passed!`
  : `${fail} test(s) failed. Click FAIL badges for diagnostics.`;
log(finalMsg);

</script>
</body>
</html>
